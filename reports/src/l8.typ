
#set par(justify: true)
#title([Численные методы: лабораторная работа №4])

Выполнил *Клименко В. М., М8О-403Б-22*

= Цель работы
Изучить метод конечно-разностных схем для решения дифференциальных уравнений гиперболического типа.

= Задание
Используя схемы переменных направлений и дробных шагов, решить двумерную начально-краевую задачу для дифференциального уравнения параболического типа.

В различные моменты времени вычислить погрешность численного решения путем сравнения результатов с приведенным в задании аналитическим решением $U(x, y, t)$. Исследовать зависимость погрешности от сеточных параметров $tau, h_x, h_y$.

== Вариант
Вариант 10:

$
  frac(partial u, partial t) = a frac(partial^2 u, partial x^2) + b frac(partial^2 u, partial y^2) + sin(x) sin(y) (mu cos(mu t) + (a + b) sin(mu t)), \
  u (0,y,t) = 0, \
  u_x (pi,y,t) = -sin(y) sin(mu t), \
  u (x,0,t) = 0, \
  u_y (x,pi,t) = -sin(x)sin(mu t), \
  u(x, y, 0) = 0
$

Аналитическое решение: $U(x, y, t) = sin(x)sin(y)sin(mu t)$

+ $a=1,b=1,mu=1$
+ $a=2,b=1,mu=1$
+ $a=1,b=2,mu=1$
+ $a=1,b=1,mu=2$


= Решение

Решение представлено в виде библиотеки на Rust. Для запуска необходимо иметь Rust тулчейн: `rustc`, `cargo`, а также `make`. Для запуска лабораторной работы используйте команду:

```shell
make test-plot TEST_SUITE=lab_8
```

Сначала в `stdout` будут выведены сведения об ошибках и количестве итераций, выполненных определенным методом. Спустя какое-то время будет открыто GIF-изображение с эволюцией функции по времени.

Ниже приведен вывод программы при различных сетках

== `nx = 101, ny = 101, nt = 800, max_t =` $2 pi$
```
VDM t = 1.571, iter = 200: max_error = 3.155e-2
VDM t = 3.142, iter = 400: max_error = 2.345e-3
VDM t = 6.283, iter = 800: max_error = 2.005e-3
FSM t = 1.571, iter = 200: max_error = 2.979e-2
FSM t = 3.142, iter = 400: max_error = 1.426e-3
FSM t = 6.283, iter = 800: max_error = 1.292e-3
```

== `nx = 151, ny = 151, nt = 400, max_t =` $2 pi$
```
VDM t = 1.571, iter = 100: max_error = 6.227e-2
VDM t = 3.142, iter = 200: max_error = 4.759e-3
VDM t = 6.283, iter = 400: max_error = 4.049e-3
FSM t = 1.571, iter = 100: max_error = 5.872e-2
FSM t = 3.142, iter = 200: max_error = 2.823e-3
FSM t = 6.283, iter = 400: max_error = 2.565e-3
```
== `nx = 51, ny = 51, nt = 400, max_t =` $2 pi$

```
VDM t = 1.571, iter = 100: max_error = 2.186e-2
VDM t = 3.142, iter = 200: max_error = 4.650e-3
VDM t = 6.283, iter = 400: max_error = 3.990e-3
FSM t = 1.571, iter = 100: max_error = 1.836e-2
FSM t = 3.142, iter = 200: max_error = 2.848e-3
FSM t = 6.283, iter = 400: max_error = 2.570e-3
```

Как можно заметить --- чем мельче сетка, тем выше точность аппроксимации

== Графики

Скриншот GIF-изображения эволюции аналитического решения и аппрокисмаций

#figure(image("../../plots/lab8.png", height: 50%))
